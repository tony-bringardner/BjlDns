/**
 * <PRE>
 * 
 * Copyright Tony Bringarder 1998, 2025 <A href="http://bringardner.com/tony">Tony Bringardner</A>
 * 
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       <A href="http://www.apache.org/licenses/LICENSE-2.0">http://www.apache.org/licenses/LICENSE-2.0</A>
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *  </PRE>
 *   
 *   
 *	@author Tony Bringardner   
 *
 *
 * ~version~V000.00.05-V000.00.00-
 */
package us.bringardner.net.dns;

/**
This class represents the Header portion of the DNS record as described in RFC 1035
 */

public class Header extends Utility implements DNS 
{

    private static int ref = 0;

    public static final int MASK = 0x00FF; 

    //  Fields in this order
    public static final int LEN = 12; //  96 bits , six(6) 16 bit values

    /**  16 bit ID generated by requester **/
    private int   id; 


    /** 01 bit == Type of Message (QUERY or RESPONSE) **/
    private boolean qr; 

    /** 04 bit == Type of Query (QUERY, IQUERY or STATUS) **/
    private int opcode;

    /** 01 bit == Authoritative answer **/
    private boolean aa; 

    /** 01 bit == Truncated message **/
    private boolean tc; 

    /** 01 bit == Recusion Desired **/
    private boolean rd; 

    /** 01 bit == Recursion Availible **/
    private boolean ra; 

    /** 03 bit == Resereved (must be zero ) **/
    private int    z; 

    /** 04 bit == response code **/
    private int  rcode;

    /** 16 bit == entries in question **/
    private int qdcount; 

    /** 16 bit == RRs in response **/
    private int ancount; 

    /** 16 bit == RRs in AUTH(NS) Section **/
    private int nscount; 

    /** 16 bit == Additional records **/
    private int arcount; 

    /** 
	Default constructor 
     **/
    public Header() {
        //  leave this to the creator id = getRef();
        qr = false; //  Query == 0
        opcode = (byte)QUERY;
        aa = false;
        tc = false;
        rd = true;
        ra = false;
        z = 0;
        rcode = (byte)NOERROR;
        qdcount = 0;
        ancount = 0;
        nscount = 0;
        arcount = 0;
    }
    /**
	Construct a header from a byte array
     **/
    public Header(byte [] buf) {
        this(new ByteBuffer(buf));
    }
    /**
	Construct a header from a ByteBuffer\
     **/
    public Header(ByteBuffer in) 
    {
        this();
        init(in);
    }
    /**
     * Make a copy of this Header with all counts set to zero
     **/
    public Header copy()
    {
        Header ret = new Header();


        ret.setID(id); 
        ret.setQR(qr);

        ret.setOPCODE(opcode);
        ret.setAA(aa);
        ret.setTC(tc);
        ret.setRD(rd);
        ret.setRA(ra);
        ret.setRCODE(rcode);

        return ret;
    }
    
    /**
     * This is always zero.  This function
     * is just to avaoid the warnings in eclipse
     * about unused variabls.
     * 
     * @return
     */
    public int getZ() {
        return z;
    }
    
    /** Get the current value for AA (boolean Athoratative Answer) **/	
    public final boolean getAA() { return aa; }
    /** Get the number of answer Sections in this Message **/
    public final int getANCOUNT() { return ancount; }
    public final int getARCOUNT() { return arcount; }	/** Get the ID of the Header **/
    public final int   getID() { return id; }	/** Get the number of NS (Name Server) sections in this Message **/
    /** Get the Message Type of this Message (QUERY or RESPONSE) **/
    public final  boolean getMessageType() { return qr; }
    public  final int getNSCOUNT() { return nscount; }	/** Get the OPCODE of this Message (QUERY, IQUERY or STATUS) **/
    public final  int     getOPCODE() { return opcode; }/** Get the number of Question Sections in this Message **/
    public  final int getQDCOUNT() { return qdcount; }/** Same as getOPCODE **/
    /** Get the current value of QR (same as getMessageType) **/
    public  final boolean getQR() 
    { 
        return qr; 
    }
    public  final int getQueryType() 
    { 
        return opcode; 
    }/** Get the current value of RCODE (Response Code) **/
    /** Get the current value of RA (Recursion Available) **/
    public  final boolean getRA() { return ra; }
    public  final int getRCODE() 
    { 
        return rcode; 
    }	/** Set the value for ID (Id for this Message) **/
    /** Get the current value of RD (Recursion Desired) **/
    public  final boolean getRD() { return rd; }
    /**
	Create a new reference number suitable for use in the Header.id field
	This could be synced but I don't see a problem if it's not
     **/
    static  int getRef() 
    {
        return ++ref;
    }
    /** Get the current value of TC (Truncated Message, 512 limit for UDP) **/
    public  final boolean getTC() { return tc; }
    /**
	Construct a header from a ByteBuffer\
     **/
    private void init(ByteBuffer in) 
    {

        id = in.nextShort();
        int tmp = in.nextShort();

        qr = isSet(tmp,15);
        opcode = (tmp>>11)&0xf;
        aa = isSet(tmp,10);
        tc = isSet(tmp, 9);
        rd = isSet(tmp, 8);
        ra = isSet(tmp, 7);
        z = 0; // bits 6,5,4
        rcode = (byte)( tmp & 0x0f); //  bits 3,2,1,0
        qdcount = in.nextShort();
        ancount = in.nextShort();
        nscount = in.nextShort();
        arcount = in.nextShort();
    }
    /** Set the value for AA (Authoritative Answer) **/
    public  final void setAA(boolean authOrNot) { aa = authOrNot; }
    /** Set the value for ANCOUNT (Number of records in the answer section) **/
    public  final void setANCOUNT(int ansCount) { ancount = (short)ansCount; }
    /** 
	Set the value for ARCOUNT (Number of additional records, 
		normally addresses for records that appear in other sections)
     **/
    public  final void setARCOUNT(int additionalCount) { arcount = (short)additionalCount; }
    public  final void setID(int idGenByRequestor) { id = idGenByRequestor; }	/** Set the value for Message Type (QR) (Query or Response) **/
    public  final void setMessageType(int qr) { setQR(qr); }/** Set the value for OPCODE ( Type of Query {QUERY, IQUERY or STATUS} ) **/
    /** Set the value for NSCOUNT (Number of Name Server records in the NS section) **/
    public  final void setNSCOUNT(int b) { nscount = (short)b; }
    public  final void setOPCODE(int cd) 
    { 
        opcode = cd; 
    }/** Set the value for QR (same as setMessageType) **/
    /** Set the value for QDCOUNT (Number of records in the Question section) **/
    public  final void setQDCOUNT(int b) { qdcount = (short)b; }
    public  final void setQR(int t) 
    {
        if( t == QUERY) {
            qr = false;
        } else if(t == RESPONSE) {
            qr = true;
        } else {
            //  Not a valid value
            throw new IllegalArgumentException("Invalid QTYPE "+t);				
        }
    }
    
    /** 
     * Set the value for QR (same as setMessageType)
     * true == QUERY , false = RESPONSE
     **/
    public  final void setQR(boolean qORnot) {
        qr = qORnot;
    }
    
    public  final void setQueryType(int newOpcode) { 
        opcode=newOpcode; 
    }
    
    /** Set the value for RCODE (Response Code) **/
    /** Set the value for RA (Recursion Available) **/
    public final  void setRA(boolean b) { 
    	ra = b; 
    }
    
    public  final void setRCODE(int cd) { 
        rcode = cd; 
    }
    
    /**
     * Write this header into a ByteBuffer
     **/ 
    /** Set the value for RD (Recursion Desired) **/
    public  final void setRD(boolean b) { rd = b; }
    /** Set the value for Reference (Used in getRef) **/
    static  void setRef(short s) {
        ref = s;
    }
    /** Set the value for TC (Truncated) **/
    public  final void setTC(boolean b) { tc = b; }
    /**
	Size of the Header 	
     **/
    public  final int size() { return LEN; }
    /**
	Return a byte arry representation of this header
     **/
    public  final byte [] toByteArray() {
        ByteBuffer b = new ByteBuffer(new byte [LEN]);
        toByteArray(b);
        return b.getBuf();
    }
    /**
     * Write this header into a ByteBuffer
     **/
    public final void toByteArray(ByteBuffer buf) 
    {

        // Set bytes 0, 1 from id
        buf.setShort(id); 

        //  Build a short from flags
        int tmp = 0;
        if(qr) {
            tmp = setBit(tmp,15);            
        }
        //  Set bits 14,13,12,11 from opcode
        tmp = (tmp | ((opcode & MASK) << 11)); 

        if( aa ) { tmp = setBit(tmp,10); } 
        if( tc ) { tmp = setBit(tmp, 9); } 
        if( rd ) { tmp = setBit(tmp, 8); } 
        if( ra ) { tmp = setBit(tmp, 7); } 

        // z == 0 nothing to do for bits 6,5,4

        //  Set bits 3,2,1,0 from rcode
        tmp = (tmp | (rcode & MASK));

        // Set bytes 2,3 from this 16 bit value
        buf.setShort(tmp);
        buf.setShort(qdcount);
        buf.setShort(ancount);
        buf.setShort(nscount);
        buf.setShort(arcount);
    }
    public String toString() 
    {
        StringBuffer ret = new StringBuffer();

        // Set bytes 0, 1 from id
        ret.append("id="+id); 
        ret.append("\n qr="+(qr?QUERYNAMES[1]:QUERYNAMES[0])+" 		/** 01 bit == Type of Message (QUERY or RESPONSE) **/");
        ret.append("\n opcode="+opcode);
        ret.append(" ("+OPCODENAMES[opcode&0xff]+")04 bit == Type of Query (QUERY, IQUERY or STATUS)");
        ret.append("\n aa="+aa);
        ret.append(" tc="+tc);
        ret.append(" rd="+rd);
        ret.append(" ra="+ra);


        // z == 0 nothing to do for bits 6,5,4

        //  Set bits 3,2,1,0 from rcode
        ret.append("\n rcode="+rcode);
        ret.append(" ("+ERRORNAMES[rcode]+")");


        // Set bytes 2,3 from this 16 bit value
        ret.append("\n qdcount="+qdcount);
        ret.append(" ancount="+ancount);
        ret.append(" nscount="+nscount);
        ret.append(" arcount="+arcount);	

        return ret.toString();
    }
}
